(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{268:function(e,n,a){"use strict";a.r(n);var t=a(38),o=Object(t.a)({},function(){var e=this,n=e.$createElement,a=e._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"spring-bean-生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spring-bean-生命周期","aria-hidden":"true"}},[e._v("#")]),e._v(" Spring Bean 生命周期")]),e._v(" "),a("ol",[a("li",[a("p",[a("code",[e._v("spring")]),e._v(" 通过我们的配置，如 "),a("code",[e._v("@ComponentScan")]),e._v(" 定义的扫描路径去找到带有 "),a("code",[e._v("@Component")]),e._v(" 的类，这个过程就是一个资源定位的过程。")])]),e._v(" "),a("li",[a("p",[e._v("一旦找到资源，那么它就开始解析，并将定义的信息保存起来，注意，此时还没有初始化 "),a("code",[e._v("bean")]),e._v("，也就没有 "),a("code",[e._v("bean")]),e._v(" 的实例，它有的仅仅是 "),a("code",[e._v("bean")]),e._v(" 的定义。")])]),e._v(" "),a("li",[a("p",[e._v("然后就会把 "),a("code",[e._v("bean")]),e._v(" 定义发布到 "),a("code",[e._v("Spring IoC")]),e._v(" 容器中。此时，"),a("code",[e._v("IoC")]),e._v(" 容器也只有bean的定义，还是没有 "),a("code",[e._v("bean")]),e._v(" 的实例生成。")])])]),e._v(" "),a("p",[e._v("在对 Bean  进行初始化的时候，如果 bean 实现了相关接口的，就会实现对应的方法。")]),e._v(" "),a("p",[e._v("如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法")]),e._v(" "),a("p",[e._v("如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入")]),e._v(" "),a("p",[e._v("如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。")]),e._v(" "),a("p",[e._v("如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。")]),e._v(" "),a("p",[e._v("如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用")]),e._v(" "),a("p",[e._v("如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。")])])},[],!1,null,null,null);n.default=o.exports}}]);